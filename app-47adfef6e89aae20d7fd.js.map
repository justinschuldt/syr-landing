{"version":3,"sources":["webpack:///./.cache/normalize-page-path.js","webpack:///./.cache/find-path.js","webpack:///./.cache/emitter.js","webpack:///./.cache/react-lifecycles-compat.js","webpack:///./src/components/App/App.tsx","webpack:///./gatsby-browser.js","webpack:///./.cache/page-renderer.js","webpack:///./.cache/api-runner-browser-plugins.js","webpack:///./.cache/register-service-worker.js","webpack:///./.cache/_this_is_virtual_fs_path_/$virtual/async-requires.js","webpack:///./node_modules/@formatjs/intl-pluralrules/dist/locale-data sync en|es|zh","webpack:///./.cache/route-announcer-props.js","webpack:///./.cache/navigation.js","webpack:///./.cache/ensure-resources.js","webpack:///./.cache/production-app.js","webpack:///./.cache/gatsby-browser-entry.js","webpack:///./node_modules/@formatjs/intl-relativetimeformat/dist/locale-data sync en|es|zh","webpack:///./.cache/strip-prefix.js","webpack:///./.cache/prefetch.js","webpack:///./.cache/loader.js","webpack:///./.cache/public-page-renderer.js","webpack:///./.cache/create-react-context.js","webpack:///./.cache/public-page-renderer-prod.js","webpack:///./src/theme.ts","webpack:///./.cache/api-runner-browser.js"],"names":["path","undefined","charAt","length","slice","pathCache","Map","matchPaths","trimPathname","rawPathname","pathname","decodeURIComponent","stripPrefix","__BASE_PATH__","split","absolutify","startsWith","URL","window","location","href","endsWith","setMatchPaths","value","findMatchPath","trimmedPathname","cleanPath","pickPaths","map","matchPath","originalPath","pick","normalizePagePath","route","grabMatchParams","params","findPath","has","get","foundPath","set","emitter","mitt","exports","polyfill","Component","App","element","theme","wrapRootElement","props","PageRenderer","render","this","pageResources","json","pageContext","__params","pathContext","pageElement","apiRunner","loader","publicLoader","createElement","component","key","page","result","pop","React","module","plugin","require","options","protocol","hostname","console","error","navigator","serviceWorker","register","then","reg","addEventListener","installingWorker","installing","log","state","controller","___swUpdated","___failedResources","reload","catch","e","components","webpackContext","req","id","webpackContextResolve","__webpack_require__","o","Error","code","keys","Object","resolve","RouteAnnouncerProps","style","position","top","width","height","padding","overflow","clip","whiteSpace","border","redirectMap","redirects","reduce","redirect","fromPath","maybeRedirect","___replace","toPath","onPreRouteUpdate","prevLocation","onRouteUpdate","navigate","to","parsePath","timeoutId","setTimeout","emit","loadPage","status","PageResourceStatus","history","replaceState","clearTimeout","webpackCompilationHash","___webpackCompilationHash","postMessage","gatsbyApi","reachNavigate","globalHistory","shouldUpdateScroll","prevRouterProps","hash","results","routerProps","getSavedScrollPosition","args","_stateStorage","read","decodeURI","RouteAnnouncer","announcementRef","createRef","componentDidUpdate","prevProps","nextProps","requestAnimationFrame","pageName","document","title","pageHeadings","querySelectorAll","textContent","newAnnouncement","current","innerText","ref","compareLocationProps","nextLocation","RouteUpdates","componentDidMount","shouldComponentUpdate","Fragment","children","EnsureResources","loadPageSync","getDerivedStateFromProps","prevState","loadResources","rawPath","setState","nextState","shallowCompare","ProdLoader","asyncRequires","setLoader","setApiRunner","___emitter","___loader","listen","action","___push","replace","___navigate","apiRunnerAsync","RouteHandler","Provider","baseuri","basepath","DataContext","createContext","GatsbyRoot","staticQueryResults","getStaticQueryResults","LocationHandler","Consumer","encodeURI","pagePath","browserLoc","match","search","SiteRoot","renderer","ReactDOM","hydrate","domReady","getElementById","prefetchPathname","enqueue","StaticQueryContext","StaticQueryDataRenderer","staticQueryData","data","query","finalData","StaticQuery","useStaticQuery","useContext","context","isNaN","Number","graphql","str","prefix","supportedPrefetchStrategy","feature","fakeLink","relList","supports","err","support","url","Promise","reject","link","setAttribute","forEach","onload","onerror","getElementsByTagName","getElementsByName","parentNode","appendChild","XMLHttpRequest","open","send","preFetched","prefetch","Success","preferDefault","m","default","createPageDataUrl","s","doFetch","method","onreadystatechange","readyState","instance","toPageResources","pageData","componentChunkName","staticQueryHashes","BaseLoader","loadComponent","inFlightNetworkRequests","pageDb","inFlightDb","staticQueryDb","pageDataDb","prefetchTriggered","Set","prefetchCompleted","memoizedGet","inFlightPromise","response","delete","prefetchDisabled","some","a","fetchPageDataJson","loadObj","retries","responseText","jsonPayload","JSON","parse","assign","payload","notFound","loadPageDataJson","all","loadAppData","allData","finalResult","componentChunkPromise","createdAt","Date","staticQueryBatchPromise","staticQueryHash","staticQueryResultsMap","shouldPrefetch","connection","effectiveType","includes","saveData","doesConnectionSupportPrefetch","add","realPath","doPrefetch","pageDataUrl","prefetchHelper","crossOrigin","as","hovering","getResourceURLsForPathname","createComponentUrls","isPageNotFound","appData","___chunkMapping","chunk","__PATH_PREFIX__","chunkName","componentUrls","_loader","getResourcesForPathname","warn","i","getResourcesForPathnameSync","ProdPageRenderer","InternalPageRenderer","color","primary","secondary","tertiary","gray","lightest","light","medium","dark","darkest","text","heading","body","disabled","spacing","unit","shape","borderRadius","small","large","plugins","api","defaultReturn","argTransform","filter","previous","next"],"mappings":"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","file":"app-47adfef6e89aae20d7fd.js","sourcesContent":["export default path => {\n  if (path === undefined) {\n    return path\n  }\n  if (path === `/`) {\n    return `/`\n  }\n  if (path.charAt(path.length - 1) === `/`) {\n    return path.slice(0, -1)\n  }\n  return path\n}\n","import { pick } from \"@reach/router/lib/utils\"\nimport stripPrefix from \"./strip-prefix\"\nimport normalizePagePath from \"./normalize-page-path\"\n\nconst pathCache = new Map()\nlet matchPaths = []\n\nconst trimPathname = rawPathname => {\n  const pathname = decodeURIComponent(rawPathname)\n  // Remove the pathPrefix from the pathname.\n  const trimmedPathname = stripPrefix(pathname, __BASE_PATH__)\n    // Remove any hashfragment\n    .split(`#`)[0]\n    // Remove search query\n    .split(`?`)[0]\n\n  return trimmedPathname\n}\n\nfunction absolutify(path) {\n  // If it's already absolute, return as-is\n  if (\n    path.startsWith(`/`) ||\n    path.startsWith(`https://`) ||\n    path.startsWith(`http://`)\n  ) {\n    return path\n  }\n  // Calculate path relative to current location, adding a trailing slash to\n  // match behavior of @reach/router\n  return new URL(\n    path,\n    window.location.href + (window.location.href.endsWith(`/`) ? `` : `/`)\n  ).pathname\n}\n\n/**\n * Set list of matchPaths\n *\n * @param {Array<{path: string, matchPath: string}>} value collection of matchPaths\n */\nexport const setMatchPaths = value => {\n  matchPaths = value\n}\n\n/**\n * Return a matchpath url\n * if `match-paths.json` contains `{ \"/foo*\": \"/page1\", ...}`, then\n * `/foo?bar=far` => `/page1`\n *\n * @param {string} rawPathname A raw pathname\n * @return {string|null}\n */\nexport const findMatchPath = rawPathname => {\n  const trimmedPathname = cleanPath(rawPathname)\n\n  const pickPaths = matchPaths.map(({ path, matchPath }) => {\n    return {\n      path: matchPath,\n      originalPath: path,\n    }\n  })\n\n  const path = pick(pickPaths, trimmedPathname)\n\n  if (path) {\n    return normalizePagePath(path.route.originalPath)\n  }\n\n  return null\n}\n\n/**\n * Return a matchpath params from reach/router rules\n * if `match-paths.json` contains `{ \":bar/*foo\" }`, and the path is /baz/zaz/zoo\n * then it returns\n *  { bar: baz, foo: zaz/zoo }\n *\n * @param {string} rawPathname A raw pathname\n * @return {object}\n */\nexport const grabMatchParams = rawPathname => {\n  const trimmedPathname = cleanPath(rawPathname)\n\n  const pickPaths = matchPaths.map(({ path, matchPath }) => {\n    return {\n      path: matchPath,\n      originalPath: path,\n    }\n  })\n\n  const path = pick(pickPaths, trimmedPathname)\n\n  if (path) {\n    return path.params\n  }\n\n  return {}\n}\n\n// Given a raw URL path, returns the cleaned version of it (trim off\n// `#` and query params), or if it matches an entry in\n// `match-paths.json`, its matched path is returned\n//\n// E.g. `/foo?bar=far` => `/foo`\n//\n// Or if `match-paths.json` contains `{ \"/foo*\": \"/page1\", ...}`, then\n// `/foo?bar=far` => `/page1`\nexport const findPath = rawPathname => {\n  const trimmedPathname = trimPathname(absolutify(rawPathname))\n  if (pathCache.has(trimmedPathname)) {\n    return pathCache.get(trimmedPathname)\n  }\n\n  let foundPath = findMatchPath(trimmedPathname)\n\n  if (!foundPath) {\n    foundPath = cleanPath(rawPathname)\n  }\n\n  pathCache.set(trimmedPathname, foundPath)\n\n  return foundPath\n}\n\n/**\n * Clean a url and converts /index.html => /\n * E.g. `/foo?bar=far` => `/foo`\n *\n * @param {string} rawPathname A raw pathname\n * @return {string}\n */\nexport const cleanPath = rawPathname => {\n  const trimmedPathname = trimPathname(absolutify(rawPathname))\n\n  let foundPath = trimmedPathname\n  if (foundPath === `/index.html`) {\n    foundPath = `/`\n  }\n\n  foundPath = normalizePagePath(foundPath)\n\n  return foundPath\n}\n","import mitt from \"mitt\"\n\nconst emitter = mitt()\nexport default emitter\n","exports.polyfill = Component => Component\n","import React, { ReactNode } from 'react';\nimport { ThemeProvider } from 'emotion-theming';\n\nimport theme from '../../theme';\n\n/**\n * This component exists to provide a reusable application wrapper for use in Gatsby API's, testing, etc.\n */\nconst App = ({ element }: { element: ReactNode }) => {\n  return <ThemeProvider theme={theme}>{element}</ThemeProvider>;\n};\n\nexport default App;\n","import React from 'react';\n\nimport { App } from './src/components/App';\n\n// Duplicated in gatsby-ssr.js for server side rendering during the build\nexport const wrapRootElement = props => <App {...props} />;\n","import React, { createElement } from \"react\"\nimport PropTypes from \"prop-types\"\nimport { publicLoader } from \"./loader\"\nimport { apiRunner } from \"./api-runner-browser\"\nimport { grabMatchParams } from \"./find-path\"\n\n// Renders page\nclass PageRenderer extends React.Component {\n  render() {\n    const props = {\n      ...this.props,\n      params: {\n        ...grabMatchParams(this.props.location.pathname),\n        ...this.props.pageResources.json.pageContext.__params,\n      },\n      pathContext: this.props.pageContext,\n    }\n\n    const [replacementElement] = apiRunner(`replaceComponentRenderer`, {\n      props: this.props,\n      loader: publicLoader,\n    })\n\n    const pageElement =\n      replacementElement ||\n      createElement(this.props.pageResources.component, {\n        ...props,\n        key: this.props.path || this.props.pageResources.page.path,\n      })\n\n    const wrappedPage = apiRunner(\n      `wrapPageElement`,\n      { element: pageElement, props },\n      pageElement,\n      ({ result }) => {\n        return { element: result, props }\n      }\n    ).pop()\n\n    return wrappedPage\n  }\n}\n\nPageRenderer.propTypes = {\n  location: PropTypes.object.isRequired,\n  pageResources: PropTypes.object.isRequired,\n  data: PropTypes.object,\n  pageContext: PropTypes.object.isRequired,\n}\n\nexport default PageRenderer\n","module.exports = [{\n      plugin: require('../node_modules/gatsby-plugin-intl/gatsby-browser.js'),\n      options: {\"plugins\":[],\"path\":\"/home/runner/work/syr-landing/syr-landing/src/locales\",\"languages\":[\"en\",\"es\",\"zh\"],\"defaultLanguage\":\"en\",\"redirect\":true},\n    },{\n      plugin: require('../gatsby-browser.js'),\n      options: {\"plugins\":[]},\n    }]\n","import { apiRunner } from \"./api-runner-browser\"\n\nif (\n  window.location.protocol !== `https:` &&\n  window.location.hostname !== `localhost`\n) {\n  console.error(\n    `Service workers can only be used over HTTPS, or on localhost for development`\n  )\n} else if (`serviceWorker` in navigator) {\n  navigator.serviceWorker\n    .register(`${__BASE_PATH__}/sw.js`)\n    .then(function (reg) {\n      reg.addEventListener(`updatefound`, () => {\n        apiRunner(`onServiceWorkerUpdateFound`, { serviceWorker: reg })\n        // The updatefound event implies that reg.installing is set; see\n        // https://w3c.github.io/ServiceWorker/#service-worker-registration-updatefound-event\n        const installingWorker = reg.installing\n        console.log(`installingWorker`, installingWorker)\n        installingWorker.addEventListener(`statechange`, () => {\n          switch (installingWorker.state) {\n            case `installed`:\n              if (navigator.serviceWorker.controller) {\n                // At this point, the old content will have been purged and the fresh content will\n                // have been added to the cache.\n\n                // We set a flag so Gatsby Link knows to refresh the page on next navigation attempt\n                window.___swUpdated = true\n                // We call the onServiceWorkerUpdateReady API so users can show update prompts.\n                apiRunner(`onServiceWorkerUpdateReady`, { serviceWorker: reg })\n\n                // If resources failed for the current page, reload.\n                if (window.___failedResources) {\n                  console.log(`resources failed, SW updated - reloading`)\n                  window.location.reload()\n                }\n              } else {\n                // At this point, everything has been precached.\n                // It's the perfect time to display a \"Content is cached for offline use.\" message.\n                console.log(`Content is now available offline!`)\n\n                // Post to service worker that install is complete.\n                // Delay to allow time for the event listener to be added --\n                // otherwise fetch is called too soon and resources aren't cached.\n                apiRunner(`onServiceWorkerInstalled`, { serviceWorker: reg })\n              }\n              break\n\n            case `redundant`:\n              console.error(`The installing service worker became redundant.`)\n              apiRunner(`onServiceWorkerRedundant`, { serviceWorker: reg })\n              break\n\n            case `activated`:\n              apiRunner(`onServiceWorkerActive`, { serviceWorker: reg })\n              break\n          }\n        })\n      })\n    })\n    .catch(function (e) {\n      console.error(`Error during service worker registration:`, e)\n    })\n}\n","// prefer default export if available\nconst preferDefault = m => (m && m.default) || m\n\nexports.components = {\n  \"component---src-pages-index-tsx\": () => import(\"./../../../src/pages/index.tsx\" /* webpackChunkName: \"component---src-pages-index-tsx\" */)\n}\n\n","var map = {\n\t\"./en\": \"Wud9\",\n\t\"./en.js\": \"Wud9\",\n\t\"./es\": \"/F5S\",\n\t\"./es.js\": \"/F5S\",\n\t\"./ses\": \"X5M3\",\n\t\"./ses.js\": \"X5M3\",\n\t\"./zh\": \"PjFX\",\n\t\"./zh.js\": \"PjFX\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"Tvs+\";","// This is extracted to separate module because it's shared\n// between browser and SSR code\nexport const RouteAnnouncerProps = {\n  id: `gatsby-announcer`,\n  style: {\n    position: `absolute`,\n    top: 0,\n    width: 1,\n    height: 1,\n    padding: 0,\n    overflow: `hidden`,\n    clip: `rect(0, 0, 0, 0)`,\n    whiteSpace: `nowrap`,\n    border: 0,\n  },\n  \"aria-live\": `assertive`,\n  \"aria-atomic\": `true`,\n}\n","import React from \"react\"\nimport PropTypes from \"prop-types\"\nimport loader, { PageResourceStatus } from \"./loader\"\nimport redirects from \"./redirects.json\"\nimport { apiRunner } from \"./api-runner-browser\"\nimport emitter from \"./emitter\"\nimport { RouteAnnouncerProps } from \"./route-announcer-props\"\nimport { navigate as reachNavigate } from \"@reach/router\"\nimport { globalHistory } from \"@reach/router/lib/history\"\nimport { parsePath } from \"gatsby-link\"\n\n// Convert to a map for faster lookup in maybeRedirect()\nconst redirectMap = redirects.reduce((map, redirect) => {\n  map[redirect.fromPath] = redirect\n  return map\n}, {})\n\nfunction maybeRedirect(pathname) {\n  const redirect = redirectMap[pathname]\n\n  if (redirect != null) {\n    if (process.env.NODE_ENV !== `production`) {\n      if (!loader.isPageNotFound(pathname)) {\n        console.error(\n          `The route \"${pathname}\" matches both a page and a redirect; this is probably not intentional.`\n        )\n      }\n    }\n\n    window.___replace(redirect.toPath)\n    return true\n  } else {\n    return false\n  }\n}\n\nconst onPreRouteUpdate = (location, prevLocation) => {\n  if (!maybeRedirect(location.pathname)) {\n    apiRunner(`onPreRouteUpdate`, { location, prevLocation })\n  }\n}\n\nconst onRouteUpdate = (location, prevLocation) => {\n  if (!maybeRedirect(location.pathname)) {\n    apiRunner(`onRouteUpdate`, { location, prevLocation })\n    if (\n      process.env.GATSBY_EXPERIMENTAL_QUERY_ON_DEMAND &&\n      process.env.GATSBY_QUERY_ON_DEMAND_LOADING_INDICATOR === `true`\n    ) {\n      emitter.emit(`onRouteUpdate`, { location, prevLocation })\n    }\n  }\n}\n\nconst navigate = (to, options = {}) => {\n  // Support forward/backward navigation with numbers\n  // navigate(-2) (jumps back 2 history steps)\n  // navigate(2)  (jumps forward 2 history steps)\n  if (typeof to === `number`) {\n    globalHistory.navigate(to)\n    return\n  }\n\n  let { pathname } = parsePath(to)\n  const redirect = redirectMap[pathname]\n\n  // If we're redirecting, just replace the passed in pathname\n  // to the one we want to redirect to.\n  if (redirect) {\n    to = redirect.toPath\n    pathname = parsePath(to).pathname\n  }\n\n  // If we had a service worker update, no matter the path, reload window and\n  // reset the pathname whitelist\n  if (window.___swUpdated) {\n    window.location = pathname\n    return\n  }\n\n  // Start a timer to wait for a second before transitioning and showing a\n  // loader in case resources aren't around yet.\n  const timeoutId = setTimeout(() => {\n    emitter.emit(`onDelayedLoadPageResources`, { pathname })\n    apiRunner(`onRouteUpdateDelayed`, {\n      location: window.location,\n    })\n  }, 1000)\n\n  loader.loadPage(pathname).then(pageResources => {\n    // If no page resources, then refresh the page\n    // Do this, rather than simply `window.location.reload()`, so that\n    // pressing the back/forward buttons work - otherwise when pressing\n    // back, the browser will just change the URL and expect JS to handle\n    // the change, which won't always work since it might not be a Gatsby\n    // page.\n    if (!pageResources || pageResources.status === PageResourceStatus.Error) {\n      window.history.replaceState({}, ``, location.href)\n      window.location = pathname\n      clearTimeout(timeoutId)\n      return\n    }\n\n    // If the loaded page has a different compilation hash to the\n    // window, then a rebuild has occurred on the server. Reload.\n    if (process.env.NODE_ENV === `production` && pageResources) {\n      if (\n        pageResources.page.webpackCompilationHash !==\n        window.___webpackCompilationHash\n      ) {\n        // Purge plugin-offline cache\n        if (\n          `serviceWorker` in navigator &&\n          navigator.serviceWorker.controller !== null &&\n          navigator.serviceWorker.controller.state === `activated`\n        ) {\n          navigator.serviceWorker.controller.postMessage({\n            gatsbyApi: `clearPathResources`,\n          })\n        }\n\n        window.location = pathname\n      }\n    }\n    reachNavigate(to, options)\n    clearTimeout(timeoutId)\n  })\n}\n\nfunction shouldUpdateScroll(prevRouterProps, { location }) {\n  const { pathname, hash } = location\n  const results = apiRunner(`shouldUpdateScroll`, {\n    prevRouterProps,\n    // `pathname` for backwards compatibility\n    pathname,\n    routerProps: { location },\n    getSavedScrollPosition: args => [\n      0,\n      this._stateStorage.read(args, args.key),\n    ],\n  })\n  if (results.length > 0) {\n    // Use the latest registered shouldUpdateScroll result, this allows users to override plugin's configuration\n    // @see https://github.com/gatsbyjs/gatsby/issues/12038\n    return results[results.length - 1]\n  }\n\n  if (prevRouterProps) {\n    const {\n      location: { pathname: oldPathname },\n    } = prevRouterProps\n    if (oldPathname === pathname) {\n      // Scroll to element if it exists, if it doesn't, or no hash is provided,\n      // scroll to top.\n      return hash ? decodeURI(hash.slice(1)) : [0, 0]\n    }\n  }\n  return true\n}\n\nfunction init() {\n  // The \"scroll-behavior\" package expects the \"action\" to be on the location\n  // object so let's copy it over.\n  globalHistory.listen(args => {\n    args.location.action = args.action\n  })\n\n  window.___push = to => navigate(to, { replace: false })\n  window.___replace = to => navigate(to, { replace: true })\n  window.___navigate = (to, options) => navigate(to, options)\n\n  // Check for initial page-load redirect\n  maybeRedirect(window.location.pathname)\n}\n\nclass RouteAnnouncer extends React.Component {\n  constructor(props) {\n    super(props)\n    this.announcementRef = React.createRef()\n  }\n\n  componentDidUpdate(prevProps, nextProps) {\n    requestAnimationFrame(() => {\n      let pageName = `new page at ${this.props.location.pathname}`\n      if (document.title) {\n        pageName = document.title\n      }\n      const pageHeadings = document.querySelectorAll(`#gatsby-focus-wrapper h1`)\n      if (pageHeadings && pageHeadings.length) {\n        pageName = pageHeadings[0].textContent\n      }\n      const newAnnouncement = `Navigated to ${pageName}`\n      if (this.announcementRef.current) {\n        const oldAnnouncement = this.announcementRef.current.innerText\n        if (oldAnnouncement !== newAnnouncement) {\n          this.announcementRef.current.innerText = newAnnouncement\n        }\n      }\n    })\n  }\n\n  render() {\n    return <div {...RouteAnnouncerProps} ref={this.announcementRef}></div>\n  }\n}\n\nconst compareLocationProps = (prevLocation, nextLocation) => {\n  if (prevLocation.href !== nextLocation.href) {\n    return true\n  }\n\n  if (prevLocation?.state?.key !== nextLocation?.state?.key) {\n    return true\n  }\n\n  return false\n}\n\n// Fire on(Pre)RouteUpdate APIs\nclass RouteUpdates extends React.Component {\n  constructor(props) {\n    super(props)\n    onPreRouteUpdate(props.location, null)\n  }\n\n  componentDidMount() {\n    onRouteUpdate(this.props.location, null)\n  }\n\n  shouldComponentUpdate(prevProps) {\n    if (compareLocationProps(prevProps.location, this.props.location)) {\n      onPreRouteUpdate(this.props.location, prevProps.location)\n      return true\n    }\n    return false\n  }\n\n  componentDidUpdate(prevProps) {\n    if (compareLocationProps(prevProps.location, this.props.location)) {\n      onRouteUpdate(this.props.location, prevProps.location)\n    }\n  }\n\n  render() {\n    return (\n      <React.Fragment>\n        {this.props.children}\n        <RouteAnnouncer location={location} />\n      </React.Fragment>\n    )\n  }\n}\n\nRouteUpdates.propTypes = {\n  location: PropTypes.object.isRequired,\n}\n\nexport { init, shouldUpdateScroll, RouteUpdates }\n","import React from \"react\"\nimport loader, { PageResourceStatus } from \"./loader\"\nimport shallowCompare from \"shallow-compare\"\n\nclass EnsureResources extends React.Component {\n  constructor(props) {\n    super()\n    const { location, pageResources } = props\n    this.state = {\n      location: { ...location },\n      pageResources: pageResources || loader.loadPageSync(location.pathname),\n    }\n  }\n\n  static getDerivedStateFromProps({ location }, prevState) {\n    if (prevState.location.href !== location.href) {\n      const pageResources = loader.loadPageSync(location.pathname)\n      return {\n        pageResources,\n        location: { ...location },\n      }\n    }\n\n    return {\n      location: { ...location },\n    }\n  }\n\n  loadResources(rawPath) {\n    loader.loadPage(rawPath).then(pageResources => {\n      if (pageResources && pageResources.status !== PageResourceStatus.Error) {\n        this.setState({\n          location: { ...window.location },\n          pageResources,\n        })\n      } else {\n        window.history.replaceState({}, ``, location.href)\n        window.location = rawPath\n      }\n    })\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    // Always return false if we're missing resources.\n    if (!nextState.pageResources) {\n      this.loadResources(nextProps.location.pathname)\n      return false\n    }\n\n    if (\n      process.env.BUILD_STAGE === `develop` &&\n      nextState.pageResources.stale\n    ) {\n      this.loadResources(nextProps.location.pathname)\n      return false\n    }\n\n    // Check if the component or json have changed.\n    if (this.state.pageResources !== nextState.pageResources) {\n      return true\n    }\n    if (\n      this.state.pageResources.component !== nextState.pageResources.component\n    ) {\n      return true\n    }\n\n    if (this.state.pageResources.json !== nextState.pageResources.json) {\n      return true\n    }\n    // Check if location has changed on a page using internal routing\n    // via matchPath configuration.\n    if (\n      this.state.location.key !== nextState.location.key &&\n      nextState.pageResources.page &&\n      (nextState.pageResources.page.matchPath ||\n        nextState.pageResources.page.path)\n    ) {\n      return true\n    }\n    return shallowCompare(this, nextProps, nextState)\n  }\n\n  render() {\n    if (process.env.NODE_ENV !== `production` && !this.state.pageResources) {\n      throw new Error(\n        `EnsureResources was not able to find resources for path: \"${this.props.location.pathname}\"\nThis typically means that an issue occurred building components for that path.\nRun \\`gatsby clean\\` to remove any cached elements.`\n      )\n    }\n\n    return this.props.children(this.state)\n  }\n}\n\nexport default EnsureResources\n","import { apiRunner, apiRunnerAsync } from \"./api-runner-browser\"\nimport React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport { Router, navigate, Location, BaseContext } from \"@reach/router\"\nimport { ScrollContext } from \"gatsby-react-router-scroll\"\nimport domReady from \"@mikaelkristiansson/domready\"\nimport { StaticQueryContext } from \"gatsby\"\nimport {\n  shouldUpdateScroll,\n  init as navigationInit,\n  RouteUpdates,\n} from \"./navigation\"\nimport emitter from \"./emitter\"\nimport PageRenderer from \"./page-renderer\"\nimport asyncRequires from \"$virtual/async-requires\"\nimport {\n  setLoader,\n  ProdLoader,\n  publicLoader,\n  PageResourceStatus,\n  getStaticQueryResults,\n} from \"./loader\"\nimport EnsureResources from \"./ensure-resources\"\nimport stripPrefix from \"./strip-prefix\"\n\n// Generated during bootstrap\nimport matchPaths from \"$virtual/match-paths.json\"\n\nconst loader = new ProdLoader(asyncRequires, matchPaths)\nsetLoader(loader)\nloader.setApiRunner(apiRunner)\n\nwindow.asyncRequires = asyncRequires\nwindow.___emitter = emitter\nwindow.___loader = publicLoader\n\nnavigationInit()\n\napiRunnerAsync(`onClientEntry`).then(() => {\n  // Let plugins register a service worker. The plugin just needs\n  // to return true.\n  if (apiRunner(`registerServiceWorker`).length > 0) {\n    require(`./register-service-worker`)\n  }\n\n  // In gatsby v2 if Router is used in page using matchPaths\n  // paths need to contain full path.\n  // For example:\n  //   - page have `/app/*` matchPath\n  //   - inside template user needs to use `/app/xyz` as path\n  // Resetting `basepath`/`baseuri` keeps current behaviour\n  // to not introduce breaking change.\n  // Remove this in v3\n  const RouteHandler = props => (\n    <BaseContext.Provider\n      value={{\n        baseuri: `/`,\n        basepath: `/`,\n      }}\n    >\n      <PageRenderer {...props} />\n    </BaseContext.Provider>\n  )\n\n  const DataContext = React.createContext({})\n\n  class GatsbyRoot extends React.Component {\n    render() {\n      const { children } = this.props\n      return (\n        <Location>\n          {({ location }) => (\n            <EnsureResources location={location}>\n              {({ pageResources, location }) => {\n                const staticQueryResults = getStaticQueryResults()\n                return (\n                  <StaticQueryContext.Provider value={staticQueryResults}>\n                    <DataContext.Provider value={{ pageResources, location }}>\n                      {children}\n                    </DataContext.Provider>\n                  </StaticQueryContext.Provider>\n                )\n              }}\n            </EnsureResources>\n          )}\n        </Location>\n      )\n    }\n  }\n\n  class LocationHandler extends React.Component {\n    render() {\n      return (\n        <DataContext.Consumer>\n          {({ pageResources, location }) => (\n            <RouteUpdates location={location}>\n              <ScrollContext\n                location={location}\n                shouldUpdateScroll={shouldUpdateScroll}\n              >\n                <Router\n                  basepath={__BASE_PATH__}\n                  location={location}\n                  id=\"gatsby-focus-wrapper\"\n                >\n                  <RouteHandler\n                    path={\n                      pageResources.page.path === `/404.html`\n                        ? stripPrefix(location.pathname, __BASE_PATH__)\n                        : encodeURI(\n                            pageResources.page.matchPath ||\n                              pageResources.page.path\n                          )\n                    }\n                    {...this.props}\n                    location={location}\n                    pageResources={pageResources}\n                    {...pageResources.json}\n                  />\n                </Router>\n              </ScrollContext>\n            </RouteUpdates>\n          )}\n        </DataContext.Consumer>\n      )\n    }\n  }\n\n  const { pagePath, location: browserLoc } = window\n\n  // Explicitly call navigate if the canonical path (window.pagePath)\n  // is different to the browser path (window.location.pathname). But\n  // only if NONE of the following conditions hold:\n  //\n  // - The url matches a client side route (page.matchPath)\n  // - it's a 404 page\n  // - it's the offline plugin shell (/offline-plugin-app-shell-fallback/)\n  if (\n    pagePath &&\n    __BASE_PATH__ + pagePath !== browserLoc.pathname &&\n    !(\n      loader.findMatchPath(stripPrefix(browserLoc.pathname, __BASE_PATH__)) ||\n      pagePath === `/404.html` ||\n      pagePath.match(/^\\/404\\/?$/) ||\n      pagePath.match(/^\\/offline-plugin-app-shell-fallback\\/?$/)\n    )\n  ) {\n    navigate(__BASE_PATH__ + pagePath + browserLoc.search + browserLoc.hash, {\n      replace: true,\n    })\n  }\n\n  publicLoader.loadPage(browserLoc.pathname).then(page => {\n    if (!page || page.status === PageResourceStatus.Error) {\n      throw new Error(\n        `page resources for ${browserLoc.pathname} not found. Not rendering React`\n      )\n    }\n\n    window.___webpackCompilationHash = page.page.webpackCompilationHash\n\n    const SiteRoot = apiRunner(\n      `wrapRootElement`,\n      { element: <LocationHandler /> },\n      <LocationHandler />,\n      ({ result }) => {\n        return { element: result }\n      }\n    ).pop()\n\n    const App = () => <GatsbyRoot>{SiteRoot}</GatsbyRoot>\n\n    const renderer = apiRunner(\n      `replaceHydrateFunction`,\n      undefined,\n      ReactDOM.hydrate\n    )[0]\n\n    domReady(() => {\n      renderer(\n        <App />,\n        typeof window !== `undefined`\n          ? document.getElementById(`___gatsby`)\n          : void 0,\n        () => {\n          apiRunner(`onInitialClientRender`)\n        }\n      )\n    })\n  })\n})\n","import React from \"react\"\nimport PropTypes from \"prop-types\"\nimport Link, {\n  withPrefix,\n  withAssetPrefix,\n  navigate,\n  push,\n  replace,\n  navigateTo,\n  parsePath,\n} from \"gatsby-link\"\nimport { useScrollRestoration } from \"gatsby-react-router-scroll\"\nimport PageRenderer from \"./public-page-renderer\"\nimport loader from \"./loader\"\n\nconst prefetchPathname = loader.enqueue\n\nconst StaticQueryContext = React.createContext({})\n\nfunction StaticQueryDataRenderer({ staticQueryData, data, query, render }) {\n  const finalData = data\n    ? data.data\n    : staticQueryData[query] && staticQueryData[query].data\n\n  return (\n    <React.Fragment>\n      {finalData && render(finalData)}\n      {!finalData && <div>Loading (StaticQuery)</div>}\n    </React.Fragment>\n  )\n}\n\nconst StaticQuery = props => {\n  const { data, query, render, children } = props\n\n  return (\n    <StaticQueryContext.Consumer>\n      {staticQueryData => (\n        <StaticQueryDataRenderer\n          data={data}\n          query={query}\n          render={render || children}\n          staticQueryData={staticQueryData}\n        />\n      )}\n    </StaticQueryContext.Consumer>\n  )\n}\n\nconst useStaticQuery = query => {\n  if (\n    typeof React.useContext !== `function` &&\n    process.env.NODE_ENV === `development`\n  ) {\n    throw new Error(\n      `You're likely using a version of React that doesn't support Hooks\\n` +\n        `Please update React and ReactDOM to 16.8.0 or later to use the useStaticQuery hook.`\n    )\n  }\n  const context = React.useContext(StaticQueryContext)\n\n  // query is a stringified number like `3303882` when wrapped with graphql, If a user forgets\n  // to wrap the query in a grqphql, then casting it to a Number results in `NaN` allowing us to\n  // catch the misuse of the API and give proper direction\n  if (isNaN(Number(query))) {\n    throw new Error(`useStaticQuery was called with a string but expects to be called using \\`graphql\\`. Try this:\n\nimport { useStaticQuery, graphql } from 'gatsby';\n\nuseStaticQuery(graphql\\`${query}\\`);\n`)\n  }\n\n  if (context[query]?.data) {\n    return context[query].data\n  } else {\n    throw new Error(\n      `The result of this StaticQuery could not be fetched.\\n\\n` +\n        `This is likely a bug in Gatsby and if refreshing the page does not fix it, ` +\n        `please open an issue in https://github.com/gatsbyjs/gatsby/issues`\n    )\n  }\n}\n\nStaticQuery.propTypes = {\n  data: PropTypes.object,\n  query: PropTypes.string.isRequired,\n  render: PropTypes.func,\n  children: PropTypes.func,\n}\n\nfunction graphql() {\n  throw new Error(\n    `It appears like Gatsby is misconfigured. Gatsby related \\`graphql\\` calls ` +\n      `are supposed to only be evaluated at compile time, and then compiled away. ` +\n      `Unfortunately, something went wrong and the query was left in the compiled code.\\n\\n` +\n      `Unless your site has a complex or custom babel/Gatsby configuration this is likely a bug in Gatsby.`\n  )\n}\n\nexport {\n  Link,\n  withAssetPrefix,\n  withPrefix,\n  graphql,\n  parsePath,\n  navigate,\n  push, // TODO replace for v3\n  replace, // TODO remove replace for v3\n  navigateTo, // TODO: remove navigateTo for v3\n  useScrollRestoration,\n  StaticQueryContext,\n  StaticQuery,\n  PageRenderer,\n  useStaticQuery,\n  prefetchPathname,\n}\n","var map = {\n\t\"./en\": \"Smhr\",\n\t\"./en.js\": \"Smhr\",\n\t\"./en.json\": \"a2ws\",\n\t\"./es\": \"/k+Y\",\n\t\"./es.js\": \"/k+Y\",\n\t\"./es.json\": \"Eo98\",\n\t\"./ses\": \"J80B\",\n\t\"./ses.js\": \"J80B\",\n\t\"./ses.json\": \"KPI6\",\n\t\"./zh\": \"ximg\",\n\t\"./zh.js\": \"ximg\",\n\t\"./zh.json\": \"oaSC\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"WvhT\";","/**\n * Remove a prefix from a string. Return the input string if the given prefix\n * isn't found.\n */\n\nexport default function stripPrefix(str, prefix = ``) {\n  if (!prefix) {\n    return str\n  }\n\n  if (str === prefix) {\n    return `/`\n  }\n\n  if (str.startsWith(`${prefix}/`)) {\n    return str.slice(prefix.length)\n  }\n\n  return str\n}\n","const support = function (feature) {\n  if (typeof document === `undefined`) {\n    return false\n  }\n  const fakeLink = document.createElement(`link`)\n  try {\n    if (fakeLink.relList && typeof fakeLink.relList.supports === `function`) {\n      return fakeLink.relList.supports(feature)\n    }\n  } catch (err) {\n    return false\n  }\n  return false\n}\n\nconst linkPrefetchStrategy = function (url, options) {\n  return new Promise((resolve, reject) => {\n    if (typeof document === `undefined`) {\n      reject()\n      return\n    }\n\n    const link = document.createElement(`link`)\n    link.setAttribute(`rel`, `prefetch`)\n    link.setAttribute(`href`, url)\n\n    Object.keys(options).forEach(key => {\n      link.setAttribute(key, options[key])\n    })\n\n    link.onload = resolve\n    link.onerror = reject\n\n    const parentElement =\n      document.getElementsByTagName(`head`)[0] ||\n      document.getElementsByName(`script`)[0].parentNode\n    parentElement.appendChild(link)\n  })\n}\n\nconst xhrPrefetchStrategy = function (url) {\n  return new Promise((resolve, reject) => {\n    const req = new XMLHttpRequest()\n    req.open(`GET`, url, true)\n\n    req.onload = () => {\n      if (req.status === 200) {\n        resolve()\n      } else {\n        reject()\n      }\n    }\n\n    req.send(null)\n  })\n}\n\nconst supportedPrefetchStrategy = support(`prefetch`)\n  ? linkPrefetchStrategy\n  : xhrPrefetchStrategy\n\nconst preFetched = {}\n\nconst prefetch = function (url, options) {\n  return new Promise(resolve => {\n    if (preFetched[url]) {\n      resolve()\n      return\n    }\n\n    supportedPrefetchStrategy(url, options)\n      .then(() => {\n        resolve()\n        preFetched[url] = true\n      })\n      .catch(() => {}) // 404s are logged to the console anyway\n  })\n}\n\nexport default prefetch\n","import prefetchHelper from \"./prefetch\"\nimport emitter from \"./emitter\"\nimport { setMatchPaths, findPath, findMatchPath } from \"./find-path\"\n\n/**\n * Available resource loading statuses\n */\nexport const PageResourceStatus = {\n  /**\n   * At least one of critical resources failed to load\n   */\n  Error: `error`,\n  /**\n   * Resources loaded successfully\n   */\n  Success: `success`,\n}\n\nconst preferDefault = m => (m && m.default) || m\n\nconst stripSurroundingSlashes = s => {\n  s = s[0] === `/` ? s.slice(1) : s\n  s = s.endsWith(`/`) ? s.slice(0, -1) : s\n  return s\n}\n\nconst createPageDataUrl = path => {\n  const fixedPath = path === `/` ? `index` : stripSurroundingSlashes(path)\n  return `${__PATH_PREFIX__}/page-data/${fixedPath}/page-data.json`\n}\n\nfunction doFetch(url, method = `GET`) {\n  return new Promise((resolve, reject) => {\n    const req = new XMLHttpRequest()\n    req.open(method, url, true)\n    req.onreadystatechange = () => {\n      if (req.readyState == 4) {\n        resolve(req)\n      }\n    }\n    req.send(null)\n  })\n}\n\nconst doesConnectionSupportPrefetch = () => {\n  if (\n    `connection` in navigator &&\n    typeof navigator.connection !== `undefined`\n  ) {\n    if ((navigator.connection.effectiveType || ``).includes(`2g`)) {\n      return false\n    }\n    if (navigator.connection.saveData) {\n      return false\n    }\n  }\n  return true\n}\n\nconst toPageResources = (pageData, component = null) => {\n  const page = {\n    componentChunkName: pageData.componentChunkName,\n    path: pageData.path,\n    webpackCompilationHash: pageData.webpackCompilationHash,\n    matchPath: pageData.matchPath,\n    staticQueryHashes: pageData.staticQueryHashes,\n  }\n\n  return {\n    component,\n    json: pageData.result,\n    page,\n  }\n}\n\nexport class BaseLoader {\n  constructor(loadComponent, matchPaths) {\n    // Map of pagePath -> Page. Where Page is an object with: {\n    //   status: PageResourceStatus.Success || PageResourceStatus.Error,\n    //   payload: PageResources, // undefined if PageResourceStatus.Error\n    // }\n    // PageResources is {\n    //   component,\n    //   json: pageData.result,\n    //   page: {\n    //     componentChunkName,\n    //     path,\n    //     webpackCompilationHash,\n    //     staticQueryHashes\n    //   },\n    //   staticQueryResults\n    // }\n    this.pageDb = new Map()\n    this.inFlightDb = new Map()\n    this.staticQueryDb = {}\n    this.pageDataDb = new Map()\n    this.prefetchTriggered = new Set()\n    this.prefetchCompleted = new Set()\n    this.loadComponent = loadComponent\n    setMatchPaths(matchPaths)\n  }\n\n  inFlightNetworkRequests = new Map()\n\n  memoizedGet(url) {\n    let inFlightPromise = this.inFlightNetworkRequests.get(url)\n\n    if (!inFlightPromise) {\n      inFlightPromise = doFetch(url, `GET`)\n      this.inFlightNetworkRequests.set(url, inFlightPromise)\n    }\n\n    // Prefer duplication with then + catch over .finally to prevent problems in ie11 + firefox\n    return inFlightPromise\n      .then(response => {\n        this.inFlightNetworkRequests.delete(url)\n        return response\n      })\n      .catch(err => {\n        this.inFlightNetworkRequests.delete(url)\n        throw err\n      })\n  }\n\n  setApiRunner(apiRunner) {\n    this.apiRunner = apiRunner\n    this.prefetchDisabled = apiRunner(`disableCorePrefetching`).some(a => a)\n  }\n\n  fetchPageDataJson(loadObj) {\n    const { pagePath, retries = 0 } = loadObj\n    const url = createPageDataUrl(pagePath)\n    return this.memoizedGet(url).then(req => {\n      const { status, responseText } = req\n\n      // Handle 200\n      if (status === 200) {\n        try {\n          const jsonPayload = JSON.parse(responseText)\n          if (jsonPayload.path === undefined) {\n            throw new Error(`not a valid pageData response`)\n          }\n\n          return Object.assign(loadObj, {\n            status: PageResourceStatus.Success,\n            payload: jsonPayload,\n          })\n        } catch (err) {\n          // continue regardless of error\n        }\n      }\n\n      // Handle 404\n      if (status === 404 || status === 200) {\n        // If the request was for a 404 page and it doesn't exist, we're done\n        if (pagePath === `/404.html`) {\n          return Object.assign(loadObj, {\n            status: PageResourceStatus.Error,\n          })\n        }\n\n        // Need some code here to cache the 404 request. In case\n        // multiple loadPageDataJsons result in 404s\n        return this.fetchPageDataJson(\n          Object.assign(loadObj, { pagePath: `/404.html`, notFound: true })\n        )\n      }\n\n      // handle 500 response (Unrecoverable)\n      if (status === 500) {\n        return Object.assign(loadObj, {\n          status: PageResourceStatus.Error,\n        })\n      }\n\n      // Handle everything else, including status === 0, and 503s. Should retry\n      if (retries < 3) {\n        return this.fetchPageDataJson(\n          Object.assign(loadObj, { retries: retries + 1 })\n        )\n      }\n\n      // Retried 3 times already, result is an error.\n      return Object.assign(loadObj, {\n        status: PageResourceStatus.Error,\n      })\n    })\n  }\n\n  loadPageDataJson(rawPath) {\n    const pagePath = findPath(rawPath)\n    if (this.pageDataDb.has(pagePath)) {\n      const pageData = this.pageDataDb.get(pagePath)\n      if (process.env.BUILD_STAGE !== `develop` || !pageData.stale) {\n        return Promise.resolve(pageData)\n      }\n    }\n\n    return this.fetchPageDataJson({ pagePath }).then(pageData => {\n      this.pageDataDb.set(pagePath, pageData)\n\n      return pageData\n    })\n  }\n\n  findMatchPath(rawPath) {\n    return findMatchPath(rawPath)\n  }\n\n  // TODO check all uses of this and whether they use undefined for page resources not exist\n  loadPage(rawPath) {\n    const pagePath = findPath(rawPath)\n    if (this.pageDb.has(pagePath)) {\n      const page = this.pageDb.get(pagePath)\n      if (process.env.BUILD_STAGE !== `develop` || !page.payload.stale) {\n        return Promise.resolve(page.payload)\n      }\n    }\n\n    if (this.inFlightDb.has(pagePath)) {\n      return this.inFlightDb.get(pagePath)\n    }\n\n    const inFlightPromise = Promise.all([\n      this.loadAppData(),\n      this.loadPageDataJson(pagePath),\n    ]).then(allData => {\n      const result = allData[1]\n      if (result.status === PageResourceStatus.Error) {\n        return {\n          status: PageResourceStatus.Error,\n        }\n      }\n\n      let pageData = result.payload\n      const { componentChunkName, staticQueryHashes = [] } = pageData\n\n      const finalResult = {}\n\n      const componentChunkPromise = this.loadComponent(componentChunkName).then(\n        component => {\n          finalResult.createdAt = new Date()\n          let pageResources\n          if (!component) {\n            finalResult.status = PageResourceStatus.Error\n          } else {\n            finalResult.status = PageResourceStatus.Success\n            if (result.notFound === true) {\n              finalResult.notFound = true\n            }\n            pageData = Object.assign(pageData, {\n              webpackCompilationHash: allData[0]\n                ? allData[0].webpackCompilationHash\n                : ``,\n            })\n            pageResources = toPageResources(pageData, component)\n          }\n          // undefined if final result is an error\n          return pageResources\n        }\n      )\n\n      const staticQueryBatchPromise = Promise.all(\n        staticQueryHashes.map(staticQueryHash => {\n          // Check for cache in case this static query result has already been loaded\n          if (this.staticQueryDb[staticQueryHash]) {\n            const jsonPayload = this.staticQueryDb[staticQueryHash]\n            return { staticQueryHash, jsonPayload }\n          }\n\n          return this.memoizedGet(\n            `${__PATH_PREFIX__}/page-data/sq/d/${staticQueryHash}.json`\n          ).then(req => {\n            const jsonPayload = JSON.parse(req.responseText)\n            return { staticQueryHash, jsonPayload }\n          })\n        })\n      ).then(staticQueryResults => {\n        const staticQueryResultsMap = {}\n\n        staticQueryResults.forEach(({ staticQueryHash, jsonPayload }) => {\n          staticQueryResultsMap[staticQueryHash] = jsonPayload\n          this.staticQueryDb[staticQueryHash] = jsonPayload\n        })\n\n        return staticQueryResultsMap\n      })\n\n      return Promise.all([componentChunkPromise, staticQueryBatchPromise]).then(\n        ([pageResources, staticQueryResults]) => {\n          let payload\n          if (pageResources) {\n            payload = { ...pageResources, staticQueryResults }\n            finalResult.payload = payload\n            emitter.emit(`onPostLoadPageResources`, {\n              page: payload,\n              pageResources: payload,\n            })\n          }\n\n          this.pageDb.set(pagePath, finalResult)\n\n          return payload\n        }\n      )\n    })\n\n    inFlightPromise\n      .then(response => {\n        this.inFlightDb.delete(pagePath)\n      })\n      .catch(error => {\n        this.inFlightDb.delete(pagePath)\n        throw error\n      })\n\n    this.inFlightDb.set(pagePath, inFlightPromise)\n\n    return inFlightPromise\n  }\n\n  // returns undefined if loading page ran into errors\n  loadPageSync(rawPath) {\n    const pagePath = findPath(rawPath)\n    if (this.pageDb.has(pagePath)) {\n      const pageData = this.pageDb.get(pagePath).payload\n      return pageData\n    }\n    return undefined\n  }\n\n  shouldPrefetch(pagePath) {\n    // Skip prefetching if we know user is on slow or constrained connection\n    if (!doesConnectionSupportPrefetch()) {\n      return false\n    }\n\n    // Check if the page exists.\n    if (this.pageDb.has(pagePath)) {\n      return false\n    }\n\n    return true\n  }\n\n  prefetch(pagePath) {\n    if (!this.shouldPrefetch(pagePath)) {\n      return false\n    }\n\n    // Tell plugins with custom prefetching logic that they should start\n    // prefetching this path.\n    if (!this.prefetchTriggered.has(pagePath)) {\n      this.apiRunner(`onPrefetchPathname`, { pathname: pagePath })\n      this.prefetchTriggered.add(pagePath)\n    }\n\n    // If a plugin has disabled core prefetching, stop now.\n    if (this.prefetchDisabled) {\n      return false\n    }\n\n    const realPath = findPath(pagePath)\n    // Todo make doPrefetch logic cacheable\n    // eslint-disable-next-line consistent-return\n    this.doPrefetch(realPath).then(() => {\n      if (!this.prefetchCompleted.has(pagePath)) {\n        this.apiRunner(`onPostPrefetchPathname`, { pathname: pagePath })\n        this.prefetchCompleted.add(pagePath)\n      }\n    })\n\n    return true\n  }\n\n  doPrefetch(pagePath) {\n    const pageDataUrl = createPageDataUrl(pagePath)\n    return prefetchHelper(pageDataUrl, {\n      crossOrigin: `anonymous`,\n      as: `fetch`,\n    }).then(() =>\n      // This was just prefetched, so will return a response from\n      // the cache instead of making another request to the server\n      this.loadPageDataJson(pagePath)\n    )\n  }\n\n  hovering(rawPath) {\n    this.loadPage(rawPath)\n  }\n\n  getResourceURLsForPathname(rawPath) {\n    const pagePath = findPath(rawPath)\n    const page = this.pageDataDb.get(pagePath)\n    if (page) {\n      const pageResources = toPageResources(page.payload)\n\n      return [\n        ...createComponentUrls(pageResources.page.componentChunkName),\n        createPageDataUrl(pagePath),\n      ]\n    } else {\n      return null\n    }\n  }\n\n  isPageNotFound(rawPath) {\n    const pagePath = findPath(rawPath)\n    const page = this.pageDb.get(pagePath)\n    return !page || page.notFound\n  }\n\n  loadAppData(retries = 0) {\n    return this.memoizedGet(`${__PATH_PREFIX__}/page-data/app-data.json`).then(\n      req => {\n        const { status, responseText } = req\n\n        let appData\n\n        if (status !== 200 && retries < 3) {\n          // Retry 3 times incase of non-200 responses\n          return this.loadAppData(retries + 1)\n        }\n\n        // Handle 200\n        if (status === 200) {\n          try {\n            const jsonPayload = JSON.parse(responseText)\n            if (jsonPayload.webpackCompilationHash === undefined) {\n              throw new Error(`not a valid app-data response`)\n            }\n\n            appData = jsonPayload\n          } catch (err) {\n            // continue regardless of error\n          }\n        }\n\n        return appData\n      }\n    )\n  }\n}\n\nconst createComponentUrls = componentChunkName =>\n  (window.___chunkMapping[componentChunkName] || []).map(\n    chunk => __PATH_PREFIX__ + chunk\n  )\n\nexport class ProdLoader extends BaseLoader {\n  constructor(asyncRequires, matchPaths) {\n    const loadComponent = chunkName =>\n      asyncRequires.components[chunkName]\n        ? asyncRequires.components[chunkName]()\n            .then(preferDefault)\n            // loader will handle the case when component is null\n            .catch(() => null)\n        : Promise.resolve()\n\n    super(loadComponent, matchPaths)\n  }\n\n  doPrefetch(pagePath) {\n    return super.doPrefetch(pagePath).then(result => {\n      if (result.status !== PageResourceStatus.Success) {\n        return Promise.resolve()\n      }\n      const pageData = result.payload\n      const chunkName = pageData.componentChunkName\n      const componentUrls = createComponentUrls(chunkName)\n      return Promise.all(componentUrls.map(prefetchHelper)).then(() => pageData)\n    })\n  }\n\n  loadPageDataJson(rawPath) {\n    return super.loadPageDataJson(rawPath).then(data => {\n      if (data.notFound) {\n        // check if html file exist using HEAD request:\n        // if it does we should navigate to it instead of showing 404\n        return doFetch(rawPath, `HEAD`).then(req => {\n          if (req.status === 200) {\n            // page (.html file) actually exist (or we asked for 404 )\n            // returning page resources status as errored to trigger\n            // regular browser navigation to given page\n            return {\n              status: PageResourceStatus.Error,\n            }\n          }\n\n          // if HEAD request wasn't 200, return notFound result\n          // and show 404 page\n          return data\n        })\n      }\n      return data\n    })\n  }\n}\n\nlet instance\n\nexport const setLoader = _loader => {\n  instance = _loader\n}\n\nexport const publicLoader = {\n  // Deprecated methods. As far as we're aware, these are only used by\n  // core gatsby and the offline plugin, however there's a very small\n  // chance they're called by others.\n  getResourcesForPathname: rawPath => {\n    console.warn(\n      `Warning: getResourcesForPathname is deprecated. Use loadPage instead`\n    )\n    return instance.i.loadPage(rawPath)\n  },\n  getResourcesForPathnameSync: rawPath => {\n    console.warn(\n      `Warning: getResourcesForPathnameSync is deprecated. Use loadPageSync instead`\n    )\n    return instance.i.loadPageSync(rawPath)\n  },\n  enqueue: rawPath => instance.prefetch(rawPath),\n\n  // Real methods\n  getResourceURLsForPathname: rawPath =>\n    instance.getResourceURLsForPathname(rawPath),\n  loadPage: rawPath => instance.loadPage(rawPath),\n  loadPageSync: rawPath => instance.loadPageSync(rawPath),\n  prefetch: rawPath => instance.prefetch(rawPath),\n  isPageNotFound: rawPath => instance.isPageNotFound(rawPath),\n  hovering: rawPath => instance.hovering(rawPath),\n  loadAppData: () => instance.loadAppData(),\n}\n\nexport default publicLoader\n\nexport function getStaticQueryResults() {\n  if (instance) {\n    return instance.staticQueryDb\n  } else {\n    return {}\n  }\n}\n","const preferDefault = m => (m && m.default) || m\n\nif (process.env.BUILD_STAGE === `develop`) {\n  module.exports = preferDefault(require(`./public-page-renderer-dev`))\n} else if (process.env.BUILD_STAGE === `build-javascript`) {\n  module.exports = preferDefault(require(`./public-page-renderer-prod`))\n} else {\n  module.exports = () => null\n}\n","/*\n  Why commonjs and not ES imports/exports?\n\n  This module is used to alias `create-react-context` package, but drop the the actual implementation part\n  because Gatsby requires version of react that has implementatoin baked in.\n  \n  Package source is using ES modules:\n    - https://github.com/jamiebuilds/create-react-context/blob/v0.3.0/src/index.js\n  \n  But to build this package `babel-plugin-add-module-exports` is used ( https://www.npmjs.com/package/babel-plugin-add-module-exports).\n  Which result in both `module.exports` and `exports.default` being set to same thing.\n\n  We don't use that babel plugin so we only have `exports.default`.\n\n  This cause problems in various 3rd party react components that rely on `module.exports` being set.\n  See https://github.com/gatsbyjs/gatsby/issues/23645 for example of it.\n  \n  Instead of adding same babel plugin we mimic output here. Adding babel plugin just for this would:\n   a) unnecesairly slow down compilation for all other files (if we just apply it everywhere)\n   b) or complicate babel-loader configuration with overwrite specifically for this file\n*/\n\nconst { createContext } = require(`react`)\n\nmodule.exports = createContext\nmodule.exports.default = createContext\n","import React from \"react\"\nimport PropTypes from \"prop-types\"\n\nimport loader from \"./loader\"\nimport InternalPageRenderer from \"./page-renderer\"\n\nconst ProdPageRenderer = ({ location }) => {\n  const pageResources = loader.loadPageSync(location.pathname)\n  if (!pageResources) {\n    return null\n  }\n  return React.createElement(InternalPageRenderer, {\n    location,\n    pageResources,\n    ...pageResources.json,\n  })\n}\n\nProdPageRenderer.propTypes = {\n  location: PropTypes.shape({\n    pathname: PropTypes.string.isRequired,\n  }).isRequired,\n}\n\nexport default ProdPageRenderer\n","import { Theme } from '@theme/styled';\n\nconst theme: Theme = {\n  color: {\n    primary: '#ffcc00',\n    secondary: '#008489',\n    tertiary: '#f39b84',\n    gray: {\n      lightest: '#faf8f5',\n      light: '#e2dedc',\n      medium: '#aaa5a3',\n      dark: '#75706b',\n      darkest: '#463b36',\n    },\n    status: {\n      error: {\n        light: '#ffeeea',\n        medium: '#ed6c4a',\n        dark: '#ba3816',\n      },\n    },\n    text: {\n      heading: '#463b36',\n      body: '#75706b',\n    },\n    disabled: '#aaa5a3',\n  },\n  spacing: {\n    unit: 8,\n  },\n  shape: {\n    borderRadius: {\n      small: 4,\n      medium: 6,\n      large: 32,\n    },\n  },\n};\n\nexport default theme;\n","const plugins = require(`./api-runner-browser-plugins`)\nconst {\n  getResourcesForPathname,\n  getResourcesForPathnameSync,\n  getResourceURLsForPathname,\n  loadPage,\n  loadPageSync,\n} = require(`./loader`).publicLoader\n\nexports.apiRunner = (api, args = {}, defaultReturn, argTransform) => {\n  // Hooks for gatsby-cypress's API handler\n  if (process.env.CYPRESS_SUPPORT) {\n    if (window.___apiHandler) {\n      window.___apiHandler(api)\n    } else if (window.___resolvedAPIs) {\n      window.___resolvedAPIs.push(api)\n    } else {\n      window.___resolvedAPIs = [api]\n    }\n  }\n\n  let results = plugins.map(plugin => {\n    if (!plugin.plugin[api]) {\n      return undefined\n    }\n\n    // Deprecated April 2019. Use `loadPageSync` instead\n    args.getResourcesForPathnameSync = getResourcesForPathnameSync\n    // Deprecated April 2019. Use `loadPage` instead\n    args.getResourcesForPathname = getResourcesForPathname\n    args.getResourceURLsForPathname = getResourceURLsForPathname\n    args.loadPage = loadPage\n    args.loadPageSync = loadPageSync\n\n    const result = plugin.plugin[api](args, plugin.options)\n    if (result && argTransform) {\n      args = argTransform({ args, result, plugin })\n    }\n    return result\n  })\n\n  // Filter out undefined results.\n  results = results.filter(result => typeof result !== `undefined`)\n\n  if (results.length > 0) {\n    return results\n  } else if (defaultReturn) {\n    return [defaultReturn]\n  } else {\n    return []\n  }\n}\n\nexports.apiRunnerAsync = (api, args, defaultReturn) =>\n  plugins.reduce(\n    (previous, next) =>\n      next.plugin[api]\n        ? previous.then(() => next.plugin[api](args, next.options))\n        : previous,\n    Promise.resolve()\n  )\n"],"sourceRoot":""}